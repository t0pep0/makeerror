package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var types = flag.String("type", "", "target type")

func filter(file os.FileInfo) bool {
	if filepath.Ext(file.Name()) == ".go" {
		if !strings.Contains(file.Name(), "generated") {
			return true
		}
	}
	return false
}

func main() {
	flag.Parse()
	if len(*types) == 0 {
		log.Fatalln("Please set types")
		return
	}
	//typeList := strings.Split(*types, ",")
	fset := token.NewFileSet()
	asts, err := parser.ParseDir(fset, ".", filter, 0)
	if err != nil {
		log.Fatal(err)
		return
	}
	var constList []string
	pkgName := ""
	for pName, astTree := range asts {
		pkgName = pName
		for _, file := range astTree.Files {
			for name, obj := range file.Scope.Objects {
				if obj.Kind == ast.Con {
					if value, ok := obj.Decl.(*ast.ValueSpec); ok {
						if cExpr, ok := value.Values[0].(*ast.CallExpr); ok {
							if ident, ok := cExpr.Fun.(*ast.Ident); ok {
								if ident.Name == *types {
									constList = append(constList, name)
								}
							}
						}
					}
				}
			}
		}
	}
	gen, err := os.Create(strings.ToLower(*types) + "_generated.go")
	if err != nil {
		log.Fatal(err)
		return
	}
	defer gen.Close()
	fmt.Fprintf(gen, "//This file generated by makeerror DO NOT CHANGE!\n")
	fmt.Fprintf(gen, "package %v\n\n", pkgName)
	fmt.Fprintf(gen, "const (\n")
	for _, c := range constList {
		fmt.Fprintf(gen, "\tstr%v = \"%[1]v\"\n", c)
	}
	fmt.Fprintf(gen, "\tmakeerrorUnknown = \"Unknown error type\"\n")
	fmt.Fprintf(gen, ")\n\n")
	abbrType := string(strings.ToLower(*types)[0])
	fmt.Fprintf(gen, "func (%v %v) Error() string{\n", abbrType, *types)
	fmt.Fprintf(gen, "\tswitch %v {\n", abbrType)
	for _, c := range constList {
		fmt.Fprintf(gen, "\t\tcase %v: return str%[1]v\n", c)
	}
	fmt.Fprintf(gen, "\t}\n")
	fmt.Fprintf(gen, "\treturn makeerrorUnknown\n")
	fmt.Fprintf(gen, "}\n")
}
